$_o-table-brands: () !default;
$_o-table-current-variant: ();
$_o-table-current-depth: 0;

/**	
* Gets a variable for the globally set brand.
* 
* @param {string} $variable
* @return {string | number | color | null}
**/
@function _oTableBrandVariable($variable) {
    $brand-config: _oTableBrandConfig($o-table-brand);
    $brand-variables: map-get($brand-config, 'variables');
    @if type-of($brand-variables) == 'map' {
        // 1. Get variable from variant configuration if relevant.
        @if length($_o-table-current-variant) > 0 {
            $variant-variables: map-get($brand-variables, _oTableQuickSort($_o-table-current-variant));
            @if type-of($variant-variables) == 'map' {
                @return _oTableBrandExtractVariable($variant-variables, $variable);
            }
        }
        // 2. Otherwise get the variable from the base brand configuration.
        @return _oTableBrandExtractVariable($brand-variables, $variable);
    }
    @return null;
}

/**
* Nested code will retrieve variables for the passed variant.
* This mixin can be nested within itself to build on a variant to target a new variant.
* If the current, globally set brand does not support the variant no CSS will be output.
*
* E.g. 
* _oTableBrandConfigureFor('inverse') {
*    // Will use the 'inverse' variant when fetching variable values.
*   _oTableBrandConfigureFor('b2b') {
*        // Will use the 'inverse,b2b' variant when fetching variable values.
*   }
* }
*
* @param {string, list} $variant
**/
@mixin _oTableBrandConfigureFor($variant) {
    @include _oTableSetBrandVariant($variant);
    @if _oTableBrandSupports($variant) {
        @content;
    }
    @include _oTableUnsetBrandVariant($variant);
}

/**
* Set a new brand variant.
*
* @param {string} $variant
**/
@mixin _oTableSetBrandVariant($variant) {
    @if $_o-table-current-depth == 0 {
        $_o-table-current-variant: if(type-of($variant) == 'list', $variant, ($variant)) !global;
    } @else {
        $_o-table-current-variant: join($_o-table-current-variant, $variant, 'comma') !global;
    }
    $_o-table-current-depth: $_o-table-current-depth + length($variant) !global;
}

/**
* No longer apply the most recently set variant.
*
* @param {string} $latest-variant
**/
@mixin _oTableUnsetBrandVariant($variant) {
    $_o-table-current-depth: $_o-table-current-depth - length($variant) !global; 
    @if $_o-table-current-depth == 0 {
        $_o-table-current-variant: () !global;
    }
    $new-variants: ();
    $n: 1;
    @while $n <= $_o-table-current-depth {
        $new-variants: join($new-variants, (nth($_o-table-current-variant, $n)), 'comma');
        $n: $n + 1;	
    }
    $_o-table-current-variant: if(length($new-variants) == 0, (), $new-variants) !global;
}

/**	
* Check the brand's settings to see if it supports a variant.
* 
* @param {string|map} $variant
* @return {boolean}
**/
@function _oTableBrandSupports($variant) {
    $brand-config: _oTableBrandConfig($o-table-brand);
    $brand-features: map-get($brand-config, 'settings');
    @if type-of($variant) == 'string' {
        $variant: ($variant);
    }
    @each $setting in $variant {
        $setting-configured: type-of($brand-features) == 'map' and map-has-key($brand-features, $setting);
        @if $setting-configured == false or map-get($brand-features, $setting) == false {
            @return false;
        }
    }
    @return true;
}

/**	
* Set brand configuration.
*
* @param {string} $brand
* @param {map} $config
**/
@mixin _oTableBrandSet($brand, $config) {
    @if type-of($config) != 'map' {
        @error 'Could not set brand "#{$brand}", it\'s config must be a map.';
    }
    $variables: map-get($config, 'variables');
    $settings: map-get($config, 'settings');
    $errorMessage: 'Could not set brand "#{$brand}".';
    @if $variables and (type-of($variables) != 'map' and type-of($variables) != 'list' ) {
        @error $errorMessage + ' Config key "variables" should be a map but is of type #{type-of($variables)}.';	
    }
    @if $settings and (type-of($settings) != 'map' and type-of($settings) != 'list' ) {
        @error $errorMessage + ' Config key "settings" should be a map but is of type #{type-of($settings)}.';	
    }
    // sort brand
    $sorted-variables: ();
    @each $key, $value in $variables {
        @if type-of($value) == 'map' {
            $key: _oTableQuickSort($key);
        }
        $sorted-variables: map-merge($sorted-variables, ($key: $value));
    }
    $_o-table-brands: map-merge($_o-table-brands, ($brand: (
        'variables': $sorted-variables,
        'settings': $settings
    ))) !global;
}

/**	
* Get a variable from a map of variables.
* Validates variable type.
*
* @param {map} $variables
* @param {string} $variable
* @return {string | number | color | null}
**/
@function _oTableBrandExtractVariable($variables, $variable) {
    @if type-of($variables) == 'map' {
        $value: map-get($variables, $variable);
        $supported-variable-types: ('string', 'number', 'color', 'null');
        @if not index($supported-variable-types, type-of($value)) {
            @error 'Brand variable "#{$variable}" is type of "#{type-of($value)}" but only be one of: #{$supported-variable-types}.';
        }
        @return $value;
    }
    @return null;
}

/**	
* Get all config for a given brand.
*
* @param {string} $brand
* @return {map}
**/
@function _oTableBrandConfig($brand) {
    // Get config for the brand.
    $brand-config: map-get($_o-table-brands, $brand);
    @if $brand-config == null {
        @error 'The brand #{$brand} has not been set.';
    }
    @return $brand-config;
}

/**	
* Quick sort, alphanumeric.
*
* @param {list} $list The list to sort.
* @return {list}
**/
@function _oTableQuickSort($list) {
    $less:  ();
    $equal: ();
    $large: ();
    @if length($list) > 1 {
        $seed: nth($list, ceil(length($list) / 2));
        @each $item in $list {
            @if $item == $seed {
                $equal: append($equal, $item);
            } @else if _oTableStringCompare($item, $seed) {
                $less: append($less, $item);
            } @else if not _oTableStringCompare($item, $seed) {
                $large: append($large, $item);
            }
        }
        @return join(join(_oTableQuickSort($less), $equal), _oTableQuickSort($large), list-separator($list));
    }
    @return $list;
}

/**	
* Compares two strings to determine which comes first
* according to the order of a given character list.
*
* @param {string} $a
* @param {string} $b
* @return {list}
**/
@function _oTableStringCompare($a, $b) {
    $character-order: ('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z');
    @if type-of($a) == 'number' and type-of($b) == 'number' {
        @return $a < $b;
    }

    $a: to-lower-case($a + unquote(''));
    $b: to-lower-case($b + unquote(''));

    @for $i from 1 through min(str-length($a), str-length($b)) {
        $char-a: str-slice($a, $i, $i);
        $char-b: str-slice($b, $i, $i);

        @if $char-a and $char-b and index($character-order, $char-a) != index($character-order, $char-b) {
            @return index($character-order, $char-a) < index($character-order, $char-b);
        }
    }

    @return str-length($a) < str-length($b);
}
