$_o-table-brands: () !default;
$_o-table-current-variant: ();
$_o-table-current-depth: 0;

/**	
* Gets a variable value from for the globally set brand for use as a property.
* If multiple variables are requested they are composed to one property.
* 
* @param {arglist} $variable
* @return {string | number | color | null}
**/
@function _oTableBrandProperty($variables...) {
    @if length($variables) == 1 {
        @return _oTableBrandGetVariableValue(nth($variables, 1));
    }
    $values: ();
    @each $variable in $variables {
        @if  $variable {
            $values: join($values,  _oTableBrandGetVariableValue($variable));
        }
    }
    @return $values;
}

/**	
* Gets a variable value from the globally set brand.
* 
* @param {string} $variable
* @return {string | number | color | null}
**/
@function _oTableBrandGetVariableValue($variable) {
    $brand-config: _oTableBrandConfig($o-table-brand);
    $variables: map-get($brand-config, 'variables');
    // Use brand variant variables if a variant is configured.
    @if length($_o-table-current-variant) > 0 {
        $variables: map-get($variables, _oTableQuickSort($_o-table-current-variant));
    }
    @if type-of($variables) == 'map' {
        @if map-has-key($variables, $variable) == false {
            @warn 'The "#{$variable}" variable is not set for the ' + if(length($_o-table-current-variant) > 0, 'variant "#{$_o-table-current-variant}" of ', '') + 'the "#{$o-table-brand}" brand.';
            @return null;
        }
        $value: map-get($variables, $variable);
         // Confirm the set value is what we expect of a brand variable.
        $supported-variable-types: ('string', 'number', 'color', 'list', 'null');
        @if not index($supported-variable-types, type-of($value)) {
            @error 'Brand variable "#{$variable}" is type of "#{type-of($value)}" but can only be one of: #{$supported-variable-types}.';
        }
        @return $value;
    }
    @warn 'Variables are not set for ' + if(length($_o-table-current-variant) > 0, 'the variant "#{$_o-table-current-variant}" of ', '') + 'the "#{$o-table-brand}" brand.';
    @return null;
}

/**
* Nested code will retrieve variables for the passed variant.
* This mixin can be nested within itself to build on a variant to target a new variant.
* If the current, globally set brand does not support the variant no CSS will be output.
*
* E.g. 
* _oTableBrandConfigureFor('inverse') {
*    // Will use the 'inverse' variant when fetching variable values.
*   _oTableBrandConfigureFor('b2b') {
*        // Will use the 'inverse,b2b' variant when fetching variable values.
*   }
* }
*
* @param {string | list} $variant
**/
@mixin _oTableBrandConfigureFor($variant) {
    @if type-of($variant) != 'list' and type-of($variant) != 'string' {
        @error 'Cound not configure for variant #{type-of($variant)} "#{$variant}", expecting a list or string.'
    };
    @include _oTableSetBrandVariant($variant);
    @if _oTableBrandSupports($variant) {
        @content;
    }
    @include _oTableUnsetBrandVariant($variant);
}

/**
* Set a new brand variant.
*
* @param {string | list} $variant
**/
@mixin _oTableSetBrandVariant($variant) {
    @if $_o-table-current-depth == 0 {
        $_o-table-current-variant: if(type-of($variant) == 'list', $variant, ($variant)) !global;
    } @else {
        $_o-table-current-variant: join($_o-table-current-variant, $variant, 'comma') !global;
    }
    $_o-table-current-depth: $_o-table-current-depth + length($variant) !global;
}

/**
* No longer apply the most recently set variant.
*
* @param {string | list} $variant
**/
@mixin _oTableUnsetBrandVariant($variant) {
    $_o-table-current-depth: $_o-table-current-depth - length($variant) !global; 
    @if $_o-table-current-depth == 0 {
        $_o-table-current-variant: () !global;
    }
    $new-variants: ();
    $n: 1;
    @while $n <= $_o-table-current-depth {
        $new-variants: join($new-variants, (nth($_o-table-current-variant, $n)), 'comma');
        $n: $n + 1;	
    }
    $_o-table-current-variant: if(length($new-variants) == 0, (), $new-variants) !global;
}

/**	
* Check the brand's settings to see if it supports a variant.
* 
* @param {string | list} $variant
* @return {boolean}
**/
@function _oTableBrandSupports($variant) {
    @if type-of($variant) != 'list' and type-of($variant) != 'string' {
        @error 'Cound not check support for variant #{type-of($variant)} "#{$variant}", expecting a list or string.'
    };
    $brand-config: _oTableBrandConfig($o-table-brand);
    $brand-features: map-get($brand-config, 'settings');
    // No settings are enabled.
    @if type-of($brand-features) != 'map' {
        @return false;
    }
    // One or more of the variant parts are not enabled e.g. 'compact' of variant ('stripe', 'compact').
    @each $setting in $variant {
        $setting-configured: type-of($brand-features) == 'map' and map-has-key($brand-features, $setting);
        @if $setting-configured == false or map-get($brand-features, $setting) == false {
            @return false;
        }
    }
    @return true;
}

/**	
* Set brand configuration.
*
* @param {string} $brand
* @param {map} $config
**/
@mixin _oTableBrandSet($brand, $config) {
    @if type-of($config) != 'map' {
        @error 'Could not set brand "#{$brand}", it\'s configuration must be a map.';
    }
    $variables: map-get($config, 'variables');
    $settings: map-get($config, 'settings');
    $errorMessage: 'Could not set brand "#{$brand}".';
    @if $variables and (type-of($variables) != 'map' and type-of($variables) != 'list' ) {
        @error $errorMessage + ' Config key "variables" should be a map but is of type #{type-of($variables)}.';	
    }
    @if $settings and (type-of($settings) != 'map' and type-of($settings) != 'list' ) {
        @error $errorMessage + ' Config key "settings" should be a map but is of type #{type-of($settings)}.';	
    }
    // Sort brand variant keys.
    // E.g. Input ('c', 'a', 'b'): (background: red) becomes ('a', 'b', 'c'): (background: red)
    $sorted-variables: ();
    @each $key, $value in $variables {
        @if type-of($value) == 'map' {
            $key: _oTableQuickSort($key);
        }
        $sorted-variables: map-merge($sorted-variables, ($key: $value));
    }
    $_o-table-brands: map-merge($_o-table-brands, ($brand: (
        'variables': $sorted-variables,
        'settings': $settings
    ))) !global;
}

/**	
* Get all config for a given brand.
*
* @param {string} $brand
* @return {map}
**/
@function _oTableBrandConfig($brand) {
    // Get config for the brand.
    $brand-config: map-get($_o-table-brands, $brand);
    @if $brand-config == null {
        @error 'The brand #{$brand} has not been set.';
    }
    @return $brand-config;
}

/**	
* Quick sort, alphanumeric.
*
* @param {list} $list The list to sort.
* @return {list}
**/
@function _oTableQuickSort($list) {
    $less:  ();
    $equal: ();
    $large: ();
    @if length($list) > 1 {
        $seed: nth($list, ceil(length($list) / 2));
        @each $item in $list {
            @if $item == $seed {
                $equal: append($equal, $item);
            } @else if _oTableStringCompare($item, $seed) {
                $less: append($less, $item);
            } @else if not _oTableStringCompare($item, $seed) {
                $large: append($large, $item);
            }
        }
        @return join(join(_oTableQuickSort($less), $equal), _oTableQuickSort($large), list-separator($list));
    }
    @return $list;
}

/**	
* Compares two strings to determine which comes first
* according to the order of a given character list.
*
* @param {string} $a
* @param {string} $b
* @return {list}
**/
@function _oTableStringCompare($a, $b) {
    $character-order: ('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z');
    @if type-of($a) == 'number' and type-of($b) == 'number' {
        @return $a < $b;
    }

    $a: to-lower-case($a + unquote(''));
    $b: to-lower-case($b + unquote(''));

    @for $i from 1 through min(str-length($a), str-length($b)) {
        $char-a: str-slice($a, $i, $i);
        $char-b: str-slice($b, $i, $i);

        @if $char-a and $char-b and index($character-order, $char-a) != index($character-order, $char-b) {
            @return index($character-order, $char-a) < index($character-order, $char-b);
        }
    }

    @return str-length($a) < str-length($b);
}
