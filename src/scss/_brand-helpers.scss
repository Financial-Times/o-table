$_o-table-brands: () !default;
$_o-table-current-variant: '';
$_o-table-last-selector: '';
$_o-table-current-depth: 0;
$sort-order: ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z") !default;

/**	
* Gets a variable for the globally set brand.
* 
* @param {string} $variable
* @param {string} $variant
* @return {string | number | color | null}
**/
@function _oTableBrandVariable($variable, $variant: $_o-table-current-variant) {
	// 1. Return the current brand value if possible.
	$brand-value: _oTableBrandGetValue($variable, $variant, $o-table-brand);
	@if $brand-value != false {
		@return $brand-value;
	}
	// 2. The current brand failed, return the whitelabel value instead.
	@if $o-table-brand != 'whitelabel' {
		$whitelabel-value: _oTableBrandGetValue($variable, $variant, 'whitelabel');
		@if $whitelabel-value != false {
			@return $whitelabel-value;
		}
	}
	// 3. There is no value for the requested variant, get a none-variant value instead.
	@if $variant != '' {
		@return _oTableBrandVariable($variable, '');
	}
	// 4. Variable not set.
	@return null;
}

/**
* Outputs a variant modifier class if enabled by the current brand setting config. 
* A variant modifier overrides the appearence of a component.
* E.g. .o-table--inverse
*
* @param {string} $variant
**/
@mixin _oTableBrandModifier($variant) {
	$_o-table-current-depth: $_o-table-current-depth + 1 !global;
	@include updateBrandVariants(#{&}, $variant);
	@if _oTableSetting($variant) {
		@content;
	}
	$_o-table-current-depth: $_o-table-current-depth - 1 !global; 
}

@mixin updateBrandVariants($current-selector, $new-variant) {
	@if $_o-table-current-depth == 1 {
		$_o-table-current-variant: '' !global;
	}
	
	@if ($_o-table-last-selector != '' and $current-selector != '' and is_superselector($current-selector, $_o-table-last-selector)) {
		$new-variants: ();
		$n: 1;
		@while $n < $_o-table-current-depth {
			$new-variants: join($new-variants, (nth($_o-table-current-variant, $n)), 'comma');
			$n: $n + 1;	
		}
		$_o-table-current-variant: $new-variants !global;
	}

	@include setBrandVariant($new-variant);

	$_o-table-last-selector: $current-selector !global;
}

@mixin setBrandVariant($variant) {
	@if $_o-table-current-variant == '' {
		$_o-table-current-variant: $variant !global;
	} @else {
		@if type-of($_o-table-current-variant) != 'list' {
			$_o-table-current-variant: ($_o-table-current-variant,) !global;
		}
		$_o-table-current-variant: join($_o-table-current-variant, ($variant)) !global;
	}
}

/**
* Outputs a feature modifier class if enabled by the current brand setting config. 
* A feature modifier can change the appearence of a component, a feature might
* rely on new markup. A variant modifier can visually override a feature's appearence.
*
* E.g. .o-table--stripes
*
* @param {string} $feature
**/
@mixin _oTableBrandFeature($feature) {
	@if _oTableSetting($feature) {
		@content;
	}
}

/**	
* A boolean flag for turning features and variants on/off for the current brand.
* 
* @param {string} $setting
* @param {string} $brand
* @return {boolean}
**/
@function _oTableSetting($setting, $brand: $o-table-brand) {
	$brand-config: _oTableBrandConfig($brand);
	$brand-features: map-get($brand-config, 'settings');
	$setting-configured: type-of($brand-features) == 'map' and map-has-key($brand-features, $setting);
	@return $setting-configured and map-get($brand-features, $setting);
}

/**	
* Set brand configuration.
*
* @param {string} $brand
* @param {map} $config
**/
@mixin _oTableBrandSet($brand, $config) {
	@if type-of($config) != 'map' {
		@error 'Could not set brand "#{$brand}", it\'s config must be a map.';
	}
	$variables: map-get($config, 'variables');
	$settings: map-get($config, 'settings');
	$errorMessage: 'Could not set brand "#{$brand}".';
	@if $variables and (type-of($variables) != 'map' and type-of($variables) != 'list' ) {
		@error $errorMessage + ' Config key "variables" should be a map but is of type #{type-of($variables)}.';	
	}
	@if $settings and (type-of($settings) != 'map' and type-of($settings) != 'list' ) {
		@error $errorMessage + ' Config key "settings" should be a map but is of type #{type-of($settings)}.';	
	}
	// sort brand
	$sorted-variables: ();
	@each $key, $value in $variables {
		@if type-of($value) == 'map' {
			$key: quick-sort($key);
		}
		$sorted-variables: map-merge($sorted-variables, ($key: $value));
	}
	$_o-table-brands: map-merge($_o-table-brands, ($brand: (
		'variables': $sorted-variables,
		'settings': $settings
	))) !global;
}

/**	
* Get a value from brand configuration. Returns `false` if 
* the variable for the variant and brand is not set.
*
* @param {string} $variable
* @param {string} $variant
* @param {string} $brand
* @return {string | number | color | null | false}
**/
@function _oTableBrandGetValue($variable, $variant, $brand) {
	// Get config for the brand.
	$brand-config: _oTableBrandConfig($brand);
	$brand-variables: map-get($brand-config, 'variables');
	@if type-of($brand-variables) == 'map' {

		@if $variant == '' {
			$value: _oTableBrandExtractVariable($brand-variables, $variable);
			@return if(map-has-key($brand-variables, $variable), $value, false);
		}

		$variant-variables: map-get($brand-variables, quick-sort($variant));
		@if type-of($variant-variables) == 'map' {
			$value: _oTableBrandExtractVariable($variant-variables, $variable);
			@return if(map-has-key($variant-variables, $variable), $value, false);
		}
	}

	@return false;
}

/**	
* Get a variable from a map of variables.
*
* @param {map} $variables
* @param {string} $variable
* @return {string | number | color | null}
* @throw Error unexpected brand variable type.
**/
@function _oTableBrandExtractVariable($variables, $variable) {
	@if type-of($variables) == 'map' {
		$value: map-get($variables, $variable);
		$supported-variable-types: ('string', 'number', 'color', "null");
		@if not index($supported-variable-types, type-of($value)) {
			@error 'Brand variable "#{$variable}" is type of "#{type-of($value)}" but only be one of: #{$supported-variable-types}.';
		}
		@return $value;
	}
	@return null;
}

/**	
* Get all config for a given brand.
*
* @param {string} $brand
* @return {map}
**/
@function _oTableBrandConfig($brand) {
	// Get config for the brand.
	$brand-config: map-get($_o-table-brands, $brand);
	@if $brand-config == null {
		@error 'Could not get brand variable "#{$variable}". The brand #{$brand} has not been set.';
	}
	@return $brand-config;
}

/// Compares two string to determine which comes first
/// @access private
/// @param {String} $a - first string
/// @parem {String} $b - second string
/// @param {List} $order - order to deal with
/// @return {Bool}
@function _str-compare($a, $b, $order) {
  @if type-of($a) == "number" and type-of($b) == "number" {
    @return $a < $b;
  }

  $a: to-lower-case($a + unquote(""));
  $b: to-lower-case($b + unquote(""));

  @for $i from 1 through min(str-length($a), str-length($b)) {
    $char-a: str-slice($a, $i, $i);
    $char-b: str-slice($b, $i, $i);

    @if $char-a and $char-b and index($order, $char-a) != index($order, $char-b) {
      @return index($order, $char-a) < index($order, $char-b);
    }
  }

  @return str-length($a) < str-length($b);
}

/// Quick sort
/// @author Hugo Giraudel
/// @param {List} $list - list to sort
/// @param {List} $order [$default-order] - order to use for sorting
/// @return {List}
/// @require {function} _str-compare
/// @require $default-order
@function quick-sort($list, $order: $sort-order) {
  $less:  ();
  $equal: ();
  $large: ();

  @if length($list) > 1 {
    $seed: nth($list, ceil(length($list) / 2));

    @each $item in $list {
      @if $item == $seed {
        $equal: append($equal, $item);
      } @else if _str-compare($item, $seed, $order) {
        $less: append($less, $item);
      } @else if not _str-compare($item, $seed, $order) {
        $large: append($large, $item);
      }
    }

    @return join(join(quick-sort($less, $order), $equal), quick-sort($large, $order), list-separator($list));
  }

  @return $list;
}